#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
LIB_DIR="${SCRIPT_DIR}/lib"
. "${LIB_DIR}/common.sh"

FORCE="${FORCE:-false}"
SHOW_RECOVERED="${SHOW_RECOVERED:-false}"
RECOVERED="${RECOVERED:-/dev/null}"

BLOB_NAME="${BLOB_NAME:-}"
if [[ -z "${BLOB_NAME}" ]]; then
    message "You must set BLOB_NAME to run"
    exit 1
fi
# Allow overriding INPUT; default to "-" (read from stdin)
INPUT="${INPUT:--}"

PRIMARY_CTX="${PRIMARY_CTX:-${TPM_ROOT}/prim${PRIM_EXTENSION}.ctx}"
PCR_POLICY="${PCR_POLICY:-${TPM_ROOT}/${BLOB_NAME}${PRIM_EXTENSION}.policy}"
SEALED_PUB="${SEALED_PUB:-${TPM_ROOT}/${BLOB_NAME}${PRIM_EXTENSION}.pub}"
SEALED_PRIV="${SEALED_PRIV:-${TPM_ROOT}/${BLOB_NAME}${PRIM_EXTENSION}.priv}"

# temporary dirs
SESSION_CTX="${SESSION_CTX:-${TEMPDIR}/session-p384.ctx}"
SEALED_CTX="${SEALED_CTX:-${TEMPDIR}/${BLOB_NAME}-p384.ctx}"


# PCRs and hash must match your primary
PCRS=0,6,7
HASH=sha384
PCR_LIST="${HASH}:${PCRS}"
AUTH_STRING="session:${SESSION_CTX}"

fail_exists "${PCR_POLICY}"
fail_exists "${SEALED_PUB}"
fail_exists "${SEALED_PRIV}"

if [[ "${RECOVERED}" = '-' ]]; then
    message 'WARNING: this will display secrets' \
            'change RECOVERED to alter this behavior'
fi

# cleanup trap
trap '
   for f in "${SESSION_CTX}" "${SEALED_CTX}"; do
       [[ -f "$f" ]] && tpm2_flushcontext "$f" >/dev/null 2>&1 || true
   done
   if [[ -n "${TEMPDIR:-}" && "$TEMPDIR" == /tmp/* ]]; then
       echo >&2 [cleanup] rm -rf -- "${TEMPDIR}"
   else
       echo >&2 "WARNING: Skipping tempdir cleanup: suspicious path '${TEMPDIR}'"
   fi
' EXIT

# Ensure primary key
if [[ ! -f "${PRIMARY_CTX}" ]]; then
    message "Generating primary key (ECC P‑384 + AES‑256‑CTR)…"
    tpm2_createprimary \
        --hierarchy 'o' \
        --hash-algorithm='sha384' \
        --key-algorithm='ecc384:aes256ctr' \
        --key-context="${PRIMARY_CTX}"
fi

# build PCR policy
message "Building PCR policy (PCRs $PCR_LIST, $HASH)…"

tpm2_startauthsession --policy-session -S "${SESSION_CTX}"
tpm2_policypcr \
    --session="${SESSION_CTX}" \
    --policy="${PCR_POLICY}" \
    --pcr-list="${PCR_LIST}"

tpm2_flushcontext "${SESSION_CTX}"

# Seal via either stdin or a file
if [[ "${INPUT}" == "-" ]]; then
  # Interactive mode: prompt for passphrase
  printf 'Enter secret: ' > /dev/tty
  read -r -s SECRET < /dev/tty
  printf '\n' > /dev/tty

message "" "Creating secret ..."
# pass SECRET via here-string into stdin
# avoids many security pitfalls of env vars / arguments
tpm2_create \
    --parent-context="${PRIMARY_CTX}" \
    --sealing-input=- \
    --policy="${PCR_POLICY}" \
    --public="${SEALED_PUB}" \
    --private="${SEALED_PRIV}" \
    <<<"${SECRET}"
else
  # read from the file pointed to by INPUT
  tpm2_create \
    --parent-context="${PRIMARY_CTX}" \
    --sealing-input="${INPUT}" \
    --policy="${PCR_POLICY}" \
    --public="${SEALED_PUB}" \
    --private="${SEALED_PRIV}"
fi

# Clear the secret from the environment
unset SECRET

message "" "Sealed blob written to 2 files:" \
    "    '$SEALED_PRIV'" \
    "    '$SEALED_PUB'"

# verify: load & unseal
message "loading secret blob…"

tpm2_load -C "${PRIMARY_CTX}" \
          -u "${SEALED_PUB}" \
          -r "${SEALED_PRIV}" \
          -c "${SEALED_CTX}"

# Start a new policy session for unsealing
message "" "starting policy session"
tpm2_startauthsession --policy-session --session="${SESSION_CTX}"

# Satisfy the PCR policy using the current PCR values specified in PCR_LIST
# This updates the session with a policy digest based on the current PCR state.
message "updating session with current PCR values"
tpm2_policypcr --session="${SESSION_CTX}" --pcr-list="${PCR_LIST}"

# Now, unseal using this policy session.
# The TPM will compare the policy digest in the session against the policy
# digest that was associated with SEALED_CTX when it was created.
# If you added auth to the sealed object:
# local SEALED_OBJECT_AUTH="the_same_password_used_during_create"
# AUTH_STRING="session:${SESSION_CTX}+password:${SEALED_OBJECT_AUTH}"
# If no separate sealed object auth (relying only on PCR policy):



if [[ "${RECOVERED}" = '-' ]]; then
    # Sadly `-o` doesn't respect `-` here. We have to condition it in this
    # script.
    message "writing to stdout"
    tpm2_unseal -c "${SEALED_CTX}" -p "${AUTH_STRING}"
else
    tpm2_unseal -c "${SEALED_CTX}" -p "${AUTH_STRING}" -o "${RECOVERED}"
fi

### don't print this message if we didn't actually write somewhere
if [[ "${RECOVERED}" == '-' ]]; then
    # The secret was already printed to stdout by tpm2_unseal in the block above.
    # You might just want a confirmation message here or nothing at all.
    message "" "Recovered secret was written to standard output."
elif [[ "${RECOVERED}" != '/dev/null' ]]; then
    # RECOVERED is a file, so display its content
    if [[ -f "${RECOVERED}" ]]; then # Check if the file actually exists
        message "" "Recovered secret: $(<"${RECOVERED}")"
    else
        message "" "ERROR: Recovered file '${RECOVERED}' not found for display."
    fi
else # RECOVERED is /dev/null
    message "" "Not echoing secret. Set RECOVERED=- to display secret values, or provide a filename."
fi

message "Success!"
echo >&2
echo >&2 "PCR Policy:   ${PCR_POLICY}"
echo >&2 "Public key:   ${SEALED_PUB}"
echo >&2 "Private key:  ${SEALED_PRIV}"
echo >&2
